<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=ascii">
<link rel=Edit-Time-Data href="./tutorial-mincaml.files/editdata.mso">
<link rel="stylesheet" href="sh.css" type="text/css">
<title>A Crash Course for the MinCaml Compiler</title>
</head>
<body bgcolor="#FFFFFF" link=blue vlink=purple class="Normal">
<div>
  <h3>Register Allocation (<tt>regAlloc.ml</tt>)</h3>
  <p><em>[Update on September 17, 2008: The register allocator now uses a simpler algorithm.  It omits the backtracking (ToSpill and NoSpill) explained below.]</em></p>
<!--
  <p><em>[Update on June 19, 2008: The Japanese paper <a href="http://min-caml.sourceforge.net/jpaper.pdf">The MinCaml Compiler</a> (Computer Software, vol. 25, no. 2, pp. 28-38, April 2008) explains regAlloc.target-latespill.ml. It omits the backtracking (ToSpill and NoSpill) explained below. This version is now recommended against the original regAlloc.ml (regAlloc.target-earlyspill.ml) because the former is simpler, faster at compile time, and as fast at runtime.]</em></p>
  <p><em>[Update on November 3, 2005: I implemented three versions of register allocation (regAlloc.notarget-nospill.ml, regAlloc.target-nospill.ml, and regAlloc.target-latespill.ml in the source code), where spilling and targeting are omitted or simplified; they have the same interface as regAlloc.ml and can be used in place of it.]</em></p>
-->
  <p>The most complex process in the MinCaml compiler is <em>register allocation</em>, which implements infinite number of variables by finite number of registers.</p>
  <p>First, as a <em>function calling convention</em>, we assign arguments from the first register toward the last register. (The MinCaml Compiler does not support too many arguments that do not fit in registers. They must be handled by programmers, for example by using tuples.) We set return values to the first register. These are processed in <a target="srcview"
href="min-caml.html#regalloc_h"><tt>RegAlloc.h</tt></a> which allocates registers in each top-level function.</p>
  <p>After that, we allocate resisters in function bodies and main routine. <a target="srcview"
href="min-caml.html#regalloc_g"><tt>RegAlloc.g</tt></a> takes an instruction sequence with a mapping <tt>regenv</tt> (from variables to registers) representing the current register assignment, and returns the instruction sequence after register allocation. The basic policy of register allocation is &quot;to avoid registers on which live (still to be used) variables are assigned.&quot; The &quot;variables still to be used&quot; are calculated by <a target="srcview"
href="min-caml.html#sparcasm_fv"><tt>SparcAsm.fv</tt></a>. However, when allocating registers in <tt>e1</tt> of <tt>Let(x, e1, e2)</tt>, not only <tt>e1</tt> but also the &quot;continuing&quot; instruction sequence <tt>e2</tt> must be taken into account for the calculation of the &quot;variables to be used.&quot; For this reason, <tt>RegAlloc.g</tt> and <a target="srcview"
href="min-caml.html#regalloc_gprime"><tt>RegAlloc.g'</tt></a>, which allocates registers in expressions, also take the &quot;still continuing &quot; instruction sequence <tt>cont</tt> and use it in the calculation of live variables.</p>
  <p>But we sometimes cannot allocate any register that is not live, since the number of variables is infinite while that of registers is not. In this case, we have to save the current value of some register to memory. This process is called <em>register spilling</em>. Unlike in imperative languages, the value of a variable in functional languages does not change after its definition. Therefore, it is better to save it <em>as early as possible</em> (if ever) in order to make the room.</p>
  <p>Thus, when a variable <tt>x</tt> needs to be saved, <a target="srcview"
href="min-caml.html#regalloc_g"><tt>RegAlloc.g</tt></a> returns a data type value <tt>ToSpill</tt> representing this need, and thereby <em>goes back to</em> the definition of <tt>x</tt> to insert a virtual instruction <tt>Save</tt>. In addition, since we want to remove <tt>x</tt> from the set of &quot;live variables&quot; at the point where <tt>x</tt> is spilled, we insert virtual instruction <tt>Forget</tt> to exclude <tt>x</tt> from the set of free variables. For this purpose, <tt>ToSpill</tt> keeps not only (the list of) spilled variables, but also the instruction sequence <tt>e</tt> in which <tt>Forget</tt> has been inserted. In this way, after saving <tt>x</tt>, we redo the register allocation against <tt>e</tt>.</p>
  <p>Saving is necessary not only when resisters are spilled, but also when <a target="srcview" href="min-caml.html#regalloc_call">functions are called</a>. MinCaml adopts the so-called <em>caller-save</em> convention, so every function call destroys the values of registers. Therefore, we need to save the values of <em>all</em> registers that are live at that point. This is why <tt>ToSpill</tt> holds the <em>list</em> of spilled variables.</p>
  <p>When saving is unnecessary, we return the register-allocated instruction sequence <tt>e'</tt> (with new <tt>regenv</tt>) in the other data type value <tt>NoSpill</tt>.</p>
  <p>A spilled variable will be used sooner or later, in which case <a target="srcview"
href="min-caml.html#regalloc_gprime"><tt>RegAlloc.g'</tt></a> (the function that allocates registers in expressions) raises an exception because it cannot find the variable in <tt>regenv</tt>. This exception is handled in function <a target="srcview"
href="min-caml.html#regalloc_unspill"><tt>RegAlloc.g'_and_restore</tt></a>, where virtual instruction <tt>Restore</tt> is inserted, which restores the value of a variable from the memory to a register.</p>
  <p>When allocating registers, we not only &quot;avoid live registers&quot; but also try to &quot;reduce unnecessary <tt>mov</tt> in the future.&quot; This is called <em>register targeting</em> or <em>register coalescing</em>. For example, if a variable being defined will be the second argument of a function call, we try to allocate it on the second register. For another example, we try to allocate a variable that will be returned as the result of a function on the first register. These are implemented in <a target="srcview"
href="min-caml.html#regalloc_target"><tt>RegAlloc.target</tt></a>. For this purpose, <tt>RegAlloc.g</tt> and <tt>RegAlloc.g'</tt> also takes register <tt>dest</tt> where the result of computation will be set.</p>
  <p><a
href="tutorial-mincaml-20.eng.htm">Next</a></p>
</div>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-1484933-2";
urchinTracker();
</script>
</body>
</html>
