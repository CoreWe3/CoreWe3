<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=ascii">
<link rel=Edit-Time-Data href="./tutorial-mincaml.files/editdata.mso">
<link rel="stylesheet" href="sh.css" type="text/css">
<title>A Crash Course for the MinCaml Compiler</title>
</head>
<body bgcolor="#FFFFFF" link=blue vlink=purple class="Normal">
<div>
  <h3>Assembly Generation (<tt>emit.ml</tt>)</h3>
  <p>At last, we reached the final phase: assembly generation. Since we have already finished the most complex part (namely, register allocation), we can just output <a target="srcview"
href="min-caml.html#sparcasm_t"><tt>SparcAsm.t</tt></a> as real SPARC assembly with no particular difficulty.</p>
  <p>Of course, however, we must implement virtual instructions. Conditional expressions are implemented by comparisons and branches. <a target="srcview"
href="min-caml.html#emit_save"><tt>Save</tt></a> and <a target="srcview" href="min-caml.html#emit_restore"><tt>Restore</tt></a> are implemented with store and load by calculating the set <a target="srcview"
href="min-caml.html#emit_stackset"><tt>stackset</tt></a> of already saved variables and the list <a target="srcview"
href="min-caml.html#emit_stackmap"><tt>stackmap</tt></a> of stack variables' locations. <a target="srcview"
href="min-caml.html#emit_call">Function calls</a> are easy, maybe except the (somewhat tricky) function <a target="srcview"
href="min-caml.html#emit_shuffle"><tt>Emit.shuffle</tt></a> to arrange arguments in the order of registers.</p>
  <p>The only non-trivial, important process in this module is <em>tail call optimization</em>. It implements function calls (<em>tail calls</em>) that have nothing afterward and do not return, by mere jump instructions instead of calls. Thanks to this optimization, recursive functions such as <tt>gcd</tt> are compiled just into the same code as loops. For this purpose, function <a target="srcview"
href="min-caml.html#emit_g"><tt>Emit.g</tt></a> which generates assembly for instruction sequences, as well as function <a target="srcview"
href="min-caml.html#emit_gprime"><tt>Emit.g'</tt></a> which generates assembly for each instruction, takes a data type value <a target="srcview"
href="min-caml.html#emit_dest"><tt>Emit.dest</tt></a> that represents whether we are in a tail position. If <tt>dest</tt> is <tt>Tail</tt>, we <a target="srcview"
href="min-caml.html#emit_tailcall">tail-call</a> another function by a jump instruction, or set the result of computation to the first register and <a target="srcview"
href="min-caml.html#emit_tailret">return</a> by the <tt>ret</tt> instruction of SPARC. If <tt>dest</tt> is <tt>NonTail(x)</tt>, we <a target="srcview"
href="min-caml.html#emit_nontail">set</a> the computation result on <tt>x</tt>.</p>
  <p>Finally, we implement the main routine <a target="srcview"
href="stub.c"><tt>stub.c</tt></a> which allocates the heap and function call stack, provide external functions <a target="srcview" href="libmincaml.S"><tt>libmincaml.S</tt></a> that are necessary for test programs, and then get a MinCaml compiler that works!</p>
</div>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-1484933-2";
urchinTracker();
</script>
</body>
</html>
