\documentclass{jarticle}
\usepackage{fullpage}
\usepackage{min-caml}

\begin{document}

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{lll}
\lefteqn{e~::=~} & & \mbox{式} \\
& c & \mbox{定数} \\
& \OP(e_1, \dots, e_n) & \mbox{プリミティブ演算} \\
& \IF~e_1~\THEN~e_2~\ELSE~e_3 & \mbox{条件分岐} \\
& \LET~x = e_1~\IN~e_2 & \mbox{変数定義} \\
& x & \mbox{変数の読み出し} \\
& \LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2 & \mbox{再帰関数定義} \\
& e~e_1~\dots~e_n & \mbox{関数呼び出し} \\
& (e_1, \dots, e_n) & \mbox{組の作成} \\
& \LET~(x_1, \dots, x_n) = e_1~\IN~e_2 & \mbox{組の読み出し} \\
& \ARR~e_1~e_2 & \mbox{配列の作成} \\
& e_1.(e_2) & \mbox{配列の読み出し} \\
& e_1.(e_2) \leftarrow e_3 & \mbox{配列への書き込み} \\
\end{array}
\]
\caption{MinCamlの抽象構文（型は省略）}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{lll}
\lefteqn{\tau~::=~} & & \mbox{型} \\
& \pi & \mbox{プリミティブ型} \\
& \tau_1 \to \dots \to \tau_n \to \tau & \mbox{関数型} \\
& \tau_1 \times \dots \times \tau_n & \mbox{組型} \\
& \tau~\ARRAY & \mbox{配列型} \\
& \alpha & \mbox{型変数（型推論用）} \\
\end{array}
\]
\caption{MinCamlの型}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{c}
\infer
{\mbox{$c$は$\pi$型の定数}}
{\Gamma \vdash c : \pi}
\qquad%
\infer
{\Gamma \vdash e_1 : \pi_1 \quad
 \dots \quad
 \Gamma \vdash e_n : \pi_n \quad \\
 \mbox{$\OP$は$\pi_1$, $\dots$, $\pi_n$型の値を受け取って$\pi$型の値を返すプリミティブ演算}}
{\Gamma \vdash \OP(e_1, \dots, e_n) : \pi}
\\ \\%
\infer
{\Gamma \vdash e_1 : \BOOL \quad
 \Gamma \vdash e_2 : \tau \quad
 \Gamma \vdash e_3 : \tau}
{\Gamma \vdash \IF~e_1~\THEN~e_2~\ELSE~e_3 : \tau}
\qquad%
\infer
{\Gamma \vdash e_1 : \tau_1 \quad
 \Gamma, x : \tau_1 \vdash e_2 : \tau_2}
{\Gamma \vdash \LET~x = e_1~\IN~e_2 : \tau_2}
\qquad%
\infer
{\Gamma(x) = \tau}
{\Gamma \vdash x : \tau}
\\ \\%
\infer
{\Gamma, x : \tau_1 \to \dots \to \tau_n \to \tau, y_1 : \tau_1, \dots, y_n : \tau_n \vdash e_1 : \tau \\
 \Gamma, x : \tau_1 \to \dots \to \tau_n \to \tau \vdash e_2 : \tau'}
{\Gamma \vdash \LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2 : \tau'}
\qquad%
\infer
{\Gamma \vdash e : \tau_1 \to \dots \to \tau_n \to \tau \\
 \Gamma \vdash e_1 : \tau_1 \quad
 \dots \quad
 \Gamma \vdash e_n : \tau_n}
{\Gamma \vdash e~e_1~\dots~e_n : \tau}
\\ \\%
\infer
{\Gamma \vdash e_1 : \tau_1 \quad
 \dots \quad
 \Gamma \vdash e_n : \tau_n}
{\Gamma \vdash (e_1, \dots, e_n) : \tau_1 \times \dots \times \tau_n}
\qquad%
\infer
{\Gamma \vdash e_1 : \tau_1 \times \dots \times \tau_n \quad
 \Gamma, x_1 : \tau_1, \dots, x_n : \tau_n \vdash e_2 : \tau}
{\Gamma \vdash \LET~(x_1, \dots, x_n) = e_1~\IN~e_2 : \tau}
\\ \\%
\infer
{\Gamma \vdash e_1 : \INT \quad
 \Gamma \vdash e_2 : \tau}
{\Gamma \vdash \ARR~e_1~e_2 : \tau~\ARRAY}
\\ \\%
\infer
{\Gamma \vdash e_1 : \tau~\ARRAY \quad
 \Gamma \vdash e_2 : \INT}
{\Gamma \vdash e_1.(e_2) : \tau}
\qquad%
\infer
{\Gamma \vdash e_1 : \tau~\ARRAY \quad
 \Gamma \vdash e_2 : \INT \quad
 \Gamma \vdash e_3 : \tau}
{\Gamma \vdash e_1.(e_2) \leftarrow e_3 : \UNIT}
\end{array}
\]
\caption{MinCamlの型つけ規則}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{ll}
\lefteqn{e~::=~} & \\
& c \\
& \OP(x_1, \dots, x_n) \\
& \IF~x = y~\THEN~e_1~\ELSE~e_2 \\
& \IF~x \le y~\THEN~e_1~\ELSE~e_2 \\
& \LET~x = e_1~\IN~e_2 \\
& x \\
& \LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2 \\
& x~y_1~\dots~y_n \\
& (x_1, \dots, x_n) \\
& \LET~(x_1, \dots, x_n) = y~\IN~e \\
& x.(y) \\
& x.(y) \leftarrow z \\
\end{array}
\]
\caption{MinCamlのK正規形（外部配列・外部関数適用は省略）}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
$\K : \texttt{Syntax.t} \to \texttt{KNormal.t}$
\[
\begin{array}{lll}
\K(c) & = & c \\
\K(\texttt{not}(e)) & = & \K(\IF~e~\THEN~\texttt{false}~\ELSE~\texttt{true}) \\
\K(e_1 = e_2) & = & \K(\IF~e_1 = e_2~\THEN~\texttt{true}~\ELSE~\texttt{false}) \\
\K(e_1 \le e_2) & = & \K(\IF~e_1 \le e_2~\THEN~\texttt{true}~\ELSE~\texttt{false}) \\
\K(\OP(e_1, \dots, e_n)) & = & \LET~x_1 = \K(e_1)~\IN~\dots~\LET~x_n = \K(e_n)~\IN~\OP(x_1, \dots, x_n) \\
& & \hfill \mbox{$\OP$が論理演算・比較以外の場合} \\
\K(\IF~\texttt{not}~e_1~\THEN~e_2~\ELSE~e_3) & = & \K(\IF~e_1~\THEN~e_3~\ELSE~e_2) \\
\K(\IF~e_1 = e_2~\THEN~e_3~\ELSE~e_4) & = & \LET~x = \K(e_1)~\IN~\LET~y = \K(e_2)~\IN \\
& & \IF~x = y~\THEN~\K(e_3)~\ELSE~\K(e_4) \\
\K(\IF~e_1 \le e_2~\THEN~e_3~\ELSE~e_4) & = & \LET~x = \K(e_1)~\IN~\LET~y = \K(e_2)~\IN \\
& & \IF~x \le y~\THEN~\K(e_3)~\ELSE~\K(e_4) \\
\K(\IF~e_1~\THEN~e_2~\ELSE~e_3) & = & \K(\IF~e_1 = \texttt{false}~\THEN~e_3~\ELSE~e_2) \\
& & \hfill \mbox{$e_1$が論理演算・比較以外の場合} \\
\K(\LET~x = e_1~\IN~e_2) & = & \LET~x = \K(e_1)~\IN~\K(e_2) \\
\K(x) & = & x \\
\K(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \LET~\REC~x~y_1~\dots~y_n = \K(e_1)~\IN~\K(e_2) \\
\K(e~e_1~\dots~e_n) & = & \LET~x = \K(e)~\IN~\LET~y_1 = \K(e_1)~\IN~\dots~\LET~y_n = \K(e_n)~\IN \\
& & x~y_1~\dots~y_n \\
\K(e_1, \dots, e_n) & = & \LET~x_1 = \K(e_1)~\IN~\dots~\LET~x_n = \K(e_n)~\IN~(x_1, \dots, x_n) \\
\K(\LET~(x_1, \dots, x_n) = e_1~\IN~e_2) & = & \LET~y = \K(e_1)~\IN~\LET~(x_1, \dots, x_n) = y~\IN~\K(e_2) \\
\K(\ARR~e_1~e_2) & = & \LET~x = \K(e_1)~\IN~\LET~y = \K(e_2)~\IN~\texttt{create\_array}~x~y \\
\K(e_1.(e_2)) & = & \LET~x = \K(e_1)~\IN~\LET~y = \K(e_2)~\IN~x.(y) \\
\K(e_1.(e_2) \leftarrow e_3) & = & \LET~x = \K(e_1)~\IN~\LET~y = \K(e_2)~\IN~\LET~z = \K(e_3)~\IN \\
& & x.(y) \leftarrow z \\
\end{array}
\]
\caption{K正規化（論理値の整数化と、\texttt{insert\_let}による最適化は省略）。右辺に出現していて左辺に出現していない変数は、すべて新しい(fresh)とする。}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
$\alpha : \texttt{Id.t M.t} \to \texttt{KNormal.t} \to \texttt{KNormal.t}$
\[
\begin{array}{lll}
\alpha_\e(c) & = & c \\
\alpha_\e(\OP(x_1, \dots, x_n)) & = & \OP(\e(x_1), \dots, \e(x_n)) \\
\alpha_\e(\IF~x = y~\THEN~e_1~\ELSE~e_2) & = & \IF~\e(x) = \e(y)~\THEN~\alpha_\e(e_1)~\ELSE~\alpha_\e(e_2) \\
\alpha_\e(\IF~x \le y~\THEN~e_1~\ELSE~e_2) & = & \IF~\e(x) \le \e(y)~\THEN~\alpha_\e(e_1)~\ELSE~\alpha_\e(e_2) \\
\alpha_\e(\LET~x = e_1~\IN~e_2) & = & \LET~x' = \alpha_\e(e_1)~\IN~\alpha_{\e, x \mapsto x'}(e_2) \\
\alpha_\e(x) & = & \e(x) \\
\alpha_\e(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \LET~\REC~x'~y_1'~\dots~y_n' = \alpha_{\e, x \mapsto x', y_1 \mapsto y_1', \dots, y_n \mapsto y_n'}(e_1)~\IN \\
& & \alpha_{\e, x \mapsto x'}(e_2) \\
\alpha_\e(x~y_1~\dots~y_n) & = & \e(x)~\e(y_1)~\dots~\e(y_n) \\
\alpha_\e((x_1, \dots, x_n)) & = & (\e(x_1), \dots, \e(x_n)) \\
\alpha_\e(\LET~(x_1, \dots, x_n) = y~\IN~e) & = & \LET~(x_1', \dots, x_n') = \e(y)~\IN~\alpha_{\e, x_1 \mapsto x_1', \dots, x_n \mapsto x_n'}(e) \\
\alpha_\e(x.(y)) & = & \e(x).(\e(y)) \\
\alpha_\e(x.(y) \leftarrow z) & = & \e(x).(\e(y)) \leftarrow \e(z) \\
\end{array}
\]
\caption{$\alpha$変換。$\e$は$\alpha$変換前の変数を受け取って、$\alpha$変換後の変数を返す写像。右辺に出現していて左辺に出現していない変数（$x'$など）は、すべてfreshとする。}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
$\beta : \texttt{Id.t M.t} \to \texttt{KNormal.t} \to \texttt{KNormal.t}$
\[
\begin{array}{lll}
\beta_\e(c) & = & c \\
\beta_\e(\OP(x_1, \dots, x_n)) & = & \OP(\e(x_1), \dots, \e(x_n)) \\
\beta_\e(\IF~x = y~\THEN~e_1~\ELSE~e_2) & = & \IF~\e(x) = \e(y)~\THEN~\beta_\e(e_1)~\ELSE~\beta_\e(e_2) \\
\beta_\e(\IF~x \le y~\THEN~e_1~\ELSE~e_2) & = & \IF~\e(x) \le \e(y)~\THEN~\beta_\e(e_1)~\ELSE~\beta_\e(e_2) \\
\beta_\e(\LET~x = e_1~\IN~e_2) & = & \beta_{\e, x \mapsto y}(e_2) \qquad \hfill \mbox{$\beta_\e(e_1)$が変数$y$の場合} \\
\beta_\e(\LET~x = e_1~\IN~e_2) & = & \LET~x = \beta_\e(e_1)~\IN~\beta_\e(e_2) \qquad \hfill \mbox{$\beta_\e(e_1)$が変数でない場合} \\
\beta_\e(x) & = & \e(x) \\
\beta_\e(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \LET~\REC~x~y_1~\dots~y_n = \beta_\e(e_1)~\IN~\beta_\e(e_2) \\
\beta_\e(x~y_1~\dots~y_n) & = & \e(x)~\e(y_1)~\dots~\e(y_n) \\
\beta_\e((x_1, \dots, x_n)) & = & (\e(x_1), \dots, \e(x_n)) \\
\beta_\e(\LET~(x_1, \dots, x_n) = y~\IN~e) & = & \LET~(x_1, \dots, x_n) = \e(y)~\IN~\beta_\e(e) \\
\beta_\e(x.(y)) & = & \e(x).(\e(y)) \\
\beta_\e(x.(y) \leftarrow z) & = & \e(x).(\e(y)) \leftarrow \e(z) \\
\end{array}
\]
\caption{$\beta$簡約。$\e$は$\beta$簡約前の変数を受け取って、$\beta$簡約後の変数を返す写像。$\e(x)$が定義されていない場合は、$\e(x) = x$とみなす。}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
$\A : \texttt{KNormal.t} \to \texttt{KNormal.t}$
\[
\begin{array}{lll}
\A(c) & = & c \\
\A(\OP(x_1, \dots, x_n)) & = & \OP(x_1, \dots, x_n) \\
\A(\IF~x = y~\THEN~e_1~\ELSE~e_2) & = & \IF~x = y~\THEN~\A(e_1)~\ELSE~\A(e_2) \\
\A(\IF~x \le y~\THEN~e_1~\ELSE~e_2) & = & \IF~x \le y~\THEN~\A(e_1)~\ELSE~\A(e_2) \\
\A(\LET~x = e_1~\IN~e_2) & = & \LET~\dots~\IN~\LET~x = e_1'~\IN~\A(e_2) \\
& & \qquad \mbox{$\A(e_1) = \LET~\dots~\IN~e_1'$という形で} \\
& & \qquad \mbox{（$\LET~\dots~\IN$は0個以上の$\LET$の列）、} \\
& & \qquad \mbox{$e_1'$は$\LET$でない} \\
\A(x) & = & x \\
\A(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \LET~\REC~x~y_1~\dots~y_n = \A(e_1)~\IN~\A(e_2) \\
\A(x~y_1~\dots~y_n) & = & x~y_1~\dots~y_n \\
\A((x_1, \dots, x_n)) & = & (x_1, \dots, x_n) \\
\A(\LET~(x_1, \dots, x_n) = y~\IN~e) & = & \LET~(x_1, \dots, x_n) = y~\IN~\A(e) \\
\A(x.(y)) & = & x.(y) \\
\A(x.(y) \leftarrow z) & = & x.(y) \leftarrow z \\
\end{array}
\]
\caption{ネストした$\LET$の簡約}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
$\I : (\texttt{Id.t list} \times \texttt{KNormal.t})~\texttt{M.t} \to \texttt{KNormal.t} \to \texttt{KNormal.t}$
\[
\begin{array}{lll}
\I_\e(c) & = & c \\
\I_\e(\OP(x_1, \dots, x_n)) & = & \OP(x_1, \dots, x_n) \\
\I_\e(\IF~x = y~\THEN~e_1~\ELSE~e_2) & = & \IF~x = y~\THEN~\I_\e(e_1)~\ELSE~\I_\e(e_2) \\
\I_\e(\IF~x \le y~\THEN~e_1~\ELSE~e_2) & = & \IF~x \le y~\THEN~\I_\e(e_1)~\ELSE~\I_\e(e_2) \\
\I_\e(\LET~x = e_1~\IN~e_2) & = & \LET~x = \I_\e(e_1)~\IN~\I_\e(e_2) \\
\I_\e(x) & = & x \\
\I_\e(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \mbox{$\e' = \e, x \mapsto ((y_1, \dots, y_n), e_1)$として} \\
& & \LET~\REC~x~y_1~\dots~y_n = \I_{\e'}(e_1)~\IN~\I_{\e'}(e_2) \\
& & \hfill \mbox{$\size(e_1) \le \mathit{th}$の場合} \\
\I_\e(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \LET~\REC~x~y_1~\dots~y_n = \I_\e(e_1)~\IN~\I_\e(e_2) \\
& & \hfill \mbox{$\size(e_1) > \mathit{th}$の場合} \\
\I_\e(x~y_1~\dots~y_n) & = & \alpha_{y_1 \mapsto z_1, \dots, y_n \mapsto z_n}(e) \qquad \hfill \mbox{$\e(x) = ((z_1, \dots, z_n), e)$の場合} \\
\I_\e(x~y_1~\dots~y_n) & = & x~y_1~\dots~y_n \qquad \hfill \mbox{$\e(x)$が定義されていない場合} \\
\I_\e((x_1, \dots, x_n)) & = & (x_1, \dots, x_n) \\
\I_\e(\LET~(x_1, \dots, x_n) = y~\IN~e) & = & \LET~(x_1, \dots, x_n) = y~\IN~\I_\e(e) \\
\I_\e(x.(y)) & = & x.(y) \\
\I_\e(x.(y) \leftarrow z) & = & x.(y) \leftarrow z \\
\\
\size(c) & = & 1 \\
\size(\OP(x_1, \dots, x_n)) & = & 1 \\
\size(\IF~x = y~\THEN~e_1~\ELSE~e_2) & = & 1 + \size(e_1) + \size(e_2) \\
\size(\IF~x \le y~\THEN~e_1~\ELSE~e_2) & = & 1 + \size(e_1) + \size(e_2) \\
\size(\LET~x = e_1~\IN~e_2) & = & 1 + \size(e_1) + \size(e_2) \\
\size(x) & = & 1 \\
\size(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & 1 + \size(e_1) + \size(e_2) \\
\size(x~y_1~\dots~y_n) & = & 1 \\
\size((x_1, \dots, x_n)) & = & 1 \\
\size(\LET~(x_1, \dots, x_n) = y~\IN~e) & = & 1 + \size(e) \\
\size(x.(y)) & = & 1 \\
\size(x.(y) \leftarrow z) & = & 1 \\
\end{array}
\]
\caption{インライン展開。$\e$はサイズの小さい関数名を受け取って、仮引数と本体を返す写像。$\mathit{th}$はインライン展開する関数の最大サイズ（ユーザ指定）。}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
$\F : \texttt{KNormal.t M.t} \to \texttt{KNormal.t} \to \texttt{KNormal.t}$
\[
\begin{array}{lll}
\F_\e(c) & = & c \\
\F_\e(\OP(x_1, \dots, x_n)) & = & c \qquad \hfill \mbox{$\OP(\e(x_1), \dots, \e(x_n)) = c$の場合} \\
\F_\e(\OP(x_1, \dots, x_n)) & = & \OP(x_1, \dots, x_n) \qquad \hfill \mbox{それ以外の場合} \\
\F_\e(\IF~x = y~\THEN~e_1~\ELSE~e_2) & = & \F_\e(e_1) \qquad \hfill \mbox{$\e(x)$と$\e(y)$が等しい定数の場合} \\
\F_\e(\IF~x = y~\THEN~e_1~\ELSE~e_2) & = & \F_\e(e_2) \qquad \hfill \mbox{$\e(x)$と$\e(y)$が異なる定数の場合} \\
\F_\e(\IF~x = y~\THEN~e_1~\ELSE~e_2) & = & \IF~x = y~\THEN~\F_\e(e_1)~\ELSE~\F_\e(e_2) \qquad \hfill \mbox{それ以外の場合} \\
\F_\e(\IF~x \le y~\THEN~e_1~\ELSE~e_2) & = & \F_\e(e_1) \qquad \hfill \mbox{$\e(x)$と$\e(y)$が定数で、$\e(x) \le \e(y)$の場合} \\
\F_\e(\IF~x \le y~\THEN~e_1~\ELSE~e_2) & = & \F_\e(e_2) \qquad \hfill \mbox{$\e(x)$と$\e(y)$が定数で、$\e(x) > \e(y)$の場合} \\
\F_\e(\IF~x \le y~\THEN~e_1~\ELSE~e_2) & = & \IF~x \le y~\THEN~\F_\e(e_1)~\ELSE~\F_\e(e_2) \qquad \hfill \mbox{それ以外の場合} \\
\F_\e(\LET~x = e_1~\IN~e_2) & = & \mbox{$e_1' = \F_\e(e_1)$として} \\
& & \LET~x = e_1'~\IN~\F_{\e, x \mapsto e_1'}(e_2) \\
\F_\e(x) & = & x \\
\F_\e(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \LET~\REC~x~y_1~\dots~y_n = \F_\e(e_1)~\IN~\F_\e(e_2) \\
\F_\e(x~y_1~\dots~y_n) & = & x~y_1~\dots~y_n \\
\F_\e((x_1, \dots, x_n)) & = & (x_1, \dots, x_n) \\
\F_\e(\LET~(x_1, \dots, x_n) = y~\IN~e) & = & \LET~x_1 = y_1~\IN~\dots~\LET~x_n = y_n~\IN~\F_\e(e) \\
& & \hfill \mbox{$\e(y) = (y_1, \dots, y_n)$の場合} \\
\F_\e(\LET~(x_1, \dots, x_n) = y~\IN~e) & = & \LET~(x_1, \dots, x_n) = y~\IN~\F_\e(e) \\
\F_\e(x.(y)) & = & x.(y) \\
\F_\e(x.(y) \leftarrow z) & = & x.(y) \leftarrow z \\
\end{array}
\]
\caption{定数畳み込み。$\e$は変数を受け取って、定数を返す写像。}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
$\E : \texttt{KNormal.t} \to \texttt{KNormal.t}$
\[
\begin{array}{lll}
\E(c) & = & c \\
\E(\OP(x_1, \dots, x_n)) & = & \OP(x_1, \dots, x_n) \\
\E(\IF~x = y~\THEN~e_1~\ELSE~e_2) & = & \IF~x = y~\THEN~\E(e_1)~\ELSE~\E(e_2) \\
\E(\IF~x \le y~\THEN~e_1~\ELSE~e_2) & = & \IF~x \le y~\THEN~\E(e_1)~\ELSE~\E(e_2) \\
\E(\LET~x = e_1~\IN~e_2) & = & \E(e_2) \qquad \hfill \mbox{$\eff(\E(e_1)) = \mathit{false}$かつ$x \not\in \fv(\E(e_2))$の場合} \\
\E(\LET~x = e_1~\IN~e_2) & = & \LET~x = \E(e_1)~\IN~\E(e_2) \qquad \hfill \mbox{それ以外の場合} \\
\E(x) & = & x \\
\E(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \E(e_2) \qquad \hfill \mbox{$x \not\in \fv(\E(e_2))$の場合} \\
\E(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \LET~\REC~x~y_1~\dots~y_n = \E(e_1)~\IN~\E(e_2) \qquad \hfill \mbox{それ以外の場合}  \\
\E(x~y_1~\dots~y_n) & = & x~y_1~\dots~y_n \\
\E((x_1, \dots, x_n)) & = & (x_1, \dots, x_n) \\
\E(\LET~(x_1, \dots, x_n) = y~\IN~e) & = & \E(e) \qquad \hfill \mbox{$\{x_1, \dots, x_n\} \cap \fv(\E(e)) = \emptyset$の場合} \\
\E(\LET~(x_1, \dots, x_n) = y~\IN~e) & = & \LET~(x_1, \dots, x_n) = y~\IN~\E(e) \qquad \hfill \mbox{それ以外の場合} \\
\E(x.(y)) & = & x.(y) \\
\E(x.(y) \leftarrow z) & = & x.(y) \leftarrow z \\
\end{array}
\]
$\eff : \texttt{KNormal.t} \to \BOOL$
\[
\begin{array}{lll}
\eff(c) & = & \mathit{false} \\
\eff(\OP(x_1, \dots, x_n)) & = & \mathit{false} \\
\eff(\IF~x = y~\THEN~e_1~\ELSE~e_2) & = & \eff(e_1) \lor \eff(e_2) \\
\eff(\IF~x \le y~\THEN~e_1~\ELSE~e_2) & = & \eff(e_1) \lor \eff(e_2) \\
\eff(\LET~x = e_1~\IN~e_2) & = & \eff(e_1) \lor \eff(e_2) \\
\eff(x) & = & \mathit{false} \\
\eff(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \eff(e_2) \\
\eff(x~y_1~\dots~y_n) & = & \mathit{true} \\
\eff((x_1, \dots, x_n)) & = & \mathit{false} \\
\eff(\LET~(x_1, \dots, x_n) = y~\IN~e) & = & \eff(e) \\
\eff(x.(y)) & = & \mathit{false} \\
\eff(x.(y) \leftarrow z) & = & \mathit{true} \\
\end{array}
\]
\caption{不要定義削除(1/2)}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
$\fv : \texttt{KNormal.t} \to \texttt{S.t}$
\[
\begin{array}{lll}
\fv(c) & = & \emptyset \\
\fv(\OP(x_1, \dots, x_n)) & = & \{x_1, \dots, x_n\} \\
\fv(\IF~x = y~\THEN~e_1~\ELSE~e_2) & = & \{x, y\} \cup \fv(e_1) \cup \fv(e_2) \\
\fv(\IF~x \le y~\THEN~e_1~\ELSE~e_2) & = & \{x, y\} \cup \fv(e_1) \cup \fv(e_2) \\
\fv(\LET~x = e_1~\IN~e_2) & = & \fv(e_1) \cup (\fv(e_2) \setminus \{x\}) \\
\fv(x) & = & \{x\} \\
\fv(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & ((\fv(e_1) \setminus \{y_1, \dots, y_n\}) \cup \fv(e_2)) \setminus \{x\} \\
\fv(x~y_1~\dots~y_n) & = & \{x, y_1, \dots, y_n\} \\
\fv((x_1, \dots, x_n)) & = & \{x_1, \dots, x_n\} \\
\fv(\LET~(x_1, \dots, x_n) = y~\IN~e) & = & \{y\} \cup (\fv(e) \setminus \{x_1, \dots, x_n\}) \\
\fv(x.(y)) & = & \{x, y\} \\
\fv(x.(y) \leftarrow z) & = & \{x, y, z\} \\
\end{array}
\]
\caption{不要定義削除(2/2)}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{lll}
\lefteqn{P~::=~} & & \mbox{プログラム全体} \\
& (\{D_1, \dots, D_n\}, e) & \mbox{トップレベル関数定義の集合とメインルーチンの式} \\
\lefteqn{D~::=~} & & \mbox{トップレベル関数定義} \\
& \lab_x (y_1, \dots, y_m) (z_1, \dots, z_n) = e & \mbox{関数のラベルと仮引数、自由変数、および本体} \\
\lefteqn{e~::=~} & \\
& c \\
& \OP(x_1, \dots, x_n) \\
& \IF~x = y~\THEN~e_1~\ELSE~e_2 \\
& \IF~x \le y~\THEN~e_1~\ELSE~e_2 \\
& \LET~x = e_1~\IN~e_2 \\
& x \\
& \mkcls~x = (\lab_x, (y_1, \dots, y_n))~\IN~e & \mbox{クロージャ生成} \\
& \apcls(x, y_1, \dots, y_n) & \mbox{クロージャを用いた関数呼び出し} \\
& \apdir(\lab_x, y_1, \dots, y_n) & \mbox{クロージャを用いない関数呼び出し(known function call)} \\
& (x_1, \dots, x_n) \\
& \LET~(x_1, \dots, x_n) = y~\IN~e \\
& x.(y) \\
& x.(y) \leftarrow z \\
\end{array}
\]
\caption{クロージャ変換後の構文}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
$\C : \texttt{KNormal.t} \to \texttt{Closure.t}$
\[
\begin{array}{lll}
\C(c) & = & c \\
\C(\OP(x_1, \dots, x_n)) & = & \OP(x_1, \dots, x_n) \\
\C(\IF~x = y~\THEN~e_1~\ELSE~e_2) & = & \IF~x = y~\THEN~\C(e_1)~\ELSE~\C(e_2) \\
\C(\IF~x \le y~\THEN~e_1~\ELSE~e_2) & = & \IF~x \le y~\THEN~\C(e_1)~\ELSE~\C(e_2) \\
\C(\LET~x = e_1~\IN~e_2) & = & \LET~x = \C(e_1)~\IN~\C(e_2) \\
\C(x) & = & x \\
\C(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \mbox{$\D$に$\lab_x(y_1, \dots, y_n)(z_1, \dots, z_m) = e_1'$を加え、} \\
& & \mkcls~x = (\lab_x, (z_1, \dots, z_m))~\IN~e_2' \mbox{を返す} \\
& & \qquad \mbox{ただし$e_1' = \C(e_1)$, $e_2' = \C(e_2)$,} \\
& & \qquad \mbox{$\fv(e_1') \setminus \{x, y_1, \dots, y_n\} = \{z_1, \dots, z_m\}$} \\
\C(x~y_1~\dots~y_n) & = & \apcls(x, y_1, \dots, y_n) \\
\C((x_1, \dots, x_n)) & = & (x_1, \dots, x_n) \\
\C(\LET~(x_1, \dots, x_n) = y~\IN~e) & = & \LET~(x_1, \dots, x_n) = y~\IN~\C(e) \\
\C(x.(y)) & = & x.(y) \\
\C(x.(y) \leftarrow z) & = & x.(y) \leftarrow z \\
\end{array}
\]
$\fv : \texttt{Closure.t} \to \texttt{S.t}$
\[
\begin{array}{lll}
\fv(c) & = & \emptyset \\
\fv(\OP(x_1, \dots, x_n)) & = & \{x_1, \dots, x_n\} \\
\fv(\IF~x = y~\THEN~e_1~\ELSE~e_2) & = & \{x, y\} \cup \fv(e_1) \cup \fv(e_2) \\
\fv(\IF~x \le y~\THEN~e_1~\ELSE~e_2) & = & \{x, y\} \cup \fv(e_1) \cup \fv(e_2) \\
\fv(\LET~x = e_1~\IN~e_2) & = & \fv(e_1) \cup (\fv(e_2) \setminus \{x\}) \\
\fv(x) & = & \{x\} \\
\fv(\mkcls~x = (\lab_x, (y_1, \dots, y_n))~\IN~e) & = & \{y_1, \dots, y_n\} \cup (\fv(e) \setminus \{x\}) \\
\fv(\apcls(x, y_1, \dots, y_n)) & = & \{x, y_1, \dots, y_n\} \\
\fv(\apdir(\lab_x, y_1, \dots, y_n)) & = & \{y_1, \dots, y_n\} \\
\fv((x_1, \dots, x_n)) & = & \{x_1, \dots, x_n\} \\
\fv(\LET~(x_1, \dots, x_n) = y~\IN~e) & = & \{y\} \cup (\fv(e) \setminus \{x_1, \dots, x_n\}) \\
\fv(x.(y)) & = & \{x, y\} \\
\fv(x.(y) \leftarrow z) & = & \{x, y, z\} \\
\end{array}
\]
\caption{賢くないClosure変換$\C(e)$。$\D$はトップレベル関数定義の集合を記憶しておくためのグローバル変数。}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
$\C : \texttt{S.t} \to \texttt{KNormal.t} \to \texttt{Closure.t}$
\[
\begin{array}{lll}
\C_s(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \mbox{$\D$に$\lab_x(y_1, \dots, y_n)() = e_1'$を加え、} \\
& & \mkcls~x = (\lab_x, ())~\IN~e_2' \mbox{を返す} \\
& & \qquad \mbox{ただし$e_1' = \C_{s'}(e_1)$, $e_2' = \C_{s'}(e_2)$, $s' = s \cup \{x\}$,} \\
& & \qquad \mbox{$\fv(e_1') \setminus \{y_1, \dots, y_n\} = \emptyset$の場合} \\
\C_s(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \mbox{$\D$に$\lab_x(y_1, \dots, y_n)(z_1, \dots, z_m) = e_1'$を加え、} \\
& & \mkcls~x = (\lab_x, (z_1, \dots, z_m))~\IN~e_2' \mbox{を返す} \\
& & \qquad \mbox{ただし$e_1' = \C_s(e_1)$, $e_2' = \C_s(e_2)$,} \\
& & \qquad \mbox{$\fv(e_1') \setminus \{y_1, \dots, y_n\} \neq \emptyset$,} \\
& & \qquad \mbox{$\fv(e_1') \setminus \{x, y_1, \dots, y_n\} = \{z_1, \dots, z_m\}$の場合} \\
\C_s(x~y_1~\dots~y_n) & = & \apcls(x, y_1, \dots, y_n) \hfill \mbox{$x \not\in s$の場合} \\
\C_s(x~y_1~\dots~y_n) & = & \apdir(\lab_x, y_1, \dots, y_n) \hfill \mbox{$x \in s$の場合} \\
\end{array}
\]
\caption{やや賢いClosure変換$\C_s(e)$。$s$は自由変数がないとわかっている関数の名前の集合。}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
$\C : \texttt{S.t} \to \texttt{KNormal.t} \to \texttt{Closure.t}$
\[
\begin{array}{lll}
\C_s(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \mbox{$\D$に$\lab_x(y_1, \dots, y_n)() = e_1'$を加え、} \\
& & \mkcls~x = (\lab_x, ())~\IN~e_2' \mbox{を返す} \\
& & \qquad \mbox{ただし$e_1' = \C_{s'}(e_1)$, $e_2' = \C_{s'}(e_2)$, $s' = s \cup \{x\}$,} \\
& & \qquad \mbox{$\fv(e_1') \setminus \{y_1, \dots, y_n\} = \emptyset$かつ$x \in \fv(e_2')$の場合} \\
\C_s(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \mbox{$\D$に$\lab_x(y_1, \dots, y_n)() = e_1'$を加え、} e_2' \mbox{を返す} \\
& & \qquad \mbox{ただし$e_1' = \C_{s'}(e_1)$, $e_2' = \C_{s'}(e_2)$, $s' = s \cup \{x\}$,} \\
& & \qquad \mbox{$\fv(e_1') \setminus \{y_1, \dots, y_n\} = \emptyset$かつ$x \not\in \fv(e_2')$の場合} \\
\C_s(\LET~\REC~x~y_1~\dots~y_n = e_1~\IN~e_2) & = & \mbox{$\D$に$\lab_x(y_1, \dots, y_n)(z_1, \dots, z_m) = e_1'$を加え、} \\
& & \mkcls~x = (\lab_x, (z_1, \dots, z_m))~\IN~e_2' \mbox{を返す} \\
& & \qquad \mbox{ただし$e_1' = \C_s(e_1)$, $e_2' = \C_s(e_2)$,} \\
& & \qquad \mbox{$\fv(e_1') \setminus \{y_1, \dots, y_n\} \neq \emptyset$,} \\
& & \qquad \mbox{$\fv(e_1') \setminus \{x, y_1, \dots, y_n\} = \{z_1, \dots, z_m\}$の場合} \\
\C_s(x~y_1~\dots~y_n) & = & \apcls(x, y_1, \dots, y_n) \hfill \mbox{$x \not\in s$の場合} \\
\C_s(x~y_1~\dots~y_n) & = & \apdir(\lab_x, y_1, \dots, y_n) \hfill \mbox{$x \in s$の場合} \\
\end{array}
\]
\caption{もっと賢いClosure変換$\C_s(e)$}
}\fbox{\box0}
\end{figure*}

\clearpage % to avoid the ``too many unprocessed floats'' error

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{lll}
\lefteqn{P~::=~} \\
& (\{D_1, \dots, D_n\}, E) \\
\lefteqn{D~::=~} \\
& \lab_x (y_1, \dots, y_n) = E \\
\lefteqn{E~::=~} & & \mbox{命令の列} \\
& x \leftarrow e; E & \mbox{代入} \\
& e & \mbox{返値} \\
\lefteqn{e~::=~} & & \mbox{式} \\
& c & \mbox{即値} \\
& \lab_x & \mbox{ラベル} \\
& \OP(x_1, \dots, x_n) & \mbox{算術演算} \\
& \IF~x = y~\THEN~E_1~\ELSE~E_2 & \mbox{比較＆分岐} \\
& \IF~x \le y~\THEN~E_1~\ELSE~E_2 & \mbox{比較＆分岐} \\
& x & \mbox{\texttt{mov}命令} \\
& \apcls(x, y_1, \dots, y_n) & \mbox{クロージャを用いた関数呼び出し} \\
& \apdir(\lab_x, y_1, \dots, y_n) & \mbox{クロージャを用いない関数呼び出し} \\
& x.(y) & \mbox{ロード} \\
& x.(y) \leftarrow z & \mbox{ストア} \\
& \SAVE(x, y) & \mbox{変数$x$の値をスタック位置$y$に退避する} \\
& \REST(y) & \mbox{スタック位置$y$から値を復元する} \\
\end{array}
\]
\caption{仮想マシンコードの構文}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{lll}
\lefteqn{\V : \texttt{Closure.prog} \to \texttt{SparcAsm.prog}} \\
\V((\{D_1, \dots, D_n\}, e)) & = & (\{\V(D_1), \dots, \V(D_n)\}, \V(e)) \\
\\
\lefteqn{\V : \texttt{Closure.fundef} \to \texttt{SparcAsm.fundef}} \\
\V(\lab_x (y_1, \dots, y_n) (z_1, \dots, z_n) = e) & = & \lab_x (y_1, \dots, y_n) = z_1 \leftarrow \reg{0}.(4); \dots; z_n \leftarrow \reg{0}.(4n); \V(e) \\
\\
\lefteqn{\V : \texttt{Closure.t} \to \texttt{SparcAsm.t}} \\
\V(c) & = & c \\
\V(\OP(x_1, \dots, x_n)) & = & \OP(x_1, \dots, x_n) \\
\V(\IF~x = y~\THEN~e_1~\ELSE~e_2) & = & \IF~x = y~\THEN~\V(e_1)~\ELSE~\V(e_2) \\
\V(\IF~x \le y~\THEN~e_1~\ELSE~e_2) & = & \IF~x \le y~\THEN~\V(e_1)~\ELSE~\V(e_2) \\
\V(\LET~x = e_1~\IN~e_2) & = & x \leftarrow \V(e_1); \V(e_2) \\
\V(x) & = & x \\
\V(\mkcls~x = (\lab_x, (y_1, \dots, y_n))~\IN~e) & = & x \leftarrow \hp; \hp \leftarrow \hp + 4(n+1); z \leftarrow \lab_x; x.(0) \leftarrow z; \\
& & x.(4) \leftarrow y_1; \dots; x.(4n) \leftarrow y_n; \V(e) \\
\V(\apcls(x, y_1, \dots, y_n)) & = & \apcls(x, y_1, \dots, y_n) \\
\V(\apdir(\lab_x, y_1, \dots, y_n)) & = & \apdir(\lab_x, y_1, \dots, y_n) \\
\V((x_1, \dots, x_n)) & = & y \leftarrow \hp; \hp \leftarrow \hp + 4n; \\
& & y.(0) \leftarrow x_1; \dots; y.(4(n-1)) \leftarrow x_n; y \\
\V(\LET~(x_1, \dots, x_n) = y~\IN~e) & = & \{x_1, \dots, x_n\} \cap \fv(e) = \{x_{i_1}, \dots, x_{i_m}\} \mbox{として} \\
& & x_{i_1} \leftarrow y.(4(i_1-1)); \dots; x_{i_m} \leftarrow y.(4(i_m-1)); \V(e) \\
\V(x.(y)) & = & y' \leftarrow 4 \times y; x.(y') \\
\V(x.(y) \leftarrow z) & = & y' \leftarrow 4 \times y; x.(y') \leftarrow z \\
\end{array}
\]
\caption{仮想マシンコード生成$\V(P)$, $\V(D)$および$\V(e)$。右辺に出現して左辺に出現しない変数はfreshとする。$\hp$はヒープポインタ（専用レジスタ）。$e_1; e_2$はダミーの変数$x$について$x \leftarrow e_1; e_2$の略記。$x \leftarrow E_1; E_2$は、$E_1 = (x_1 \leftarrow e_1; \dots; x_n \leftarrow e_n; e)$として、$x_1 \leftarrow e_1; \dots; x_n \leftarrow e_n; x \leftarrow e; E_2$の略記。}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{lll}
\lefteqn{\fv : \texttt{S.t} \to \texttt{SparcAsm.t} \to \texttt{S.t}} \\
\fv_s(x \leftarrow e; E) & = & s' = \fv_s(E) \setminus \{x\} \mbox{として} \fv_{s'}(e)\\
\fv_s(e) & = & \fv_s(e) \\
\\
\lefteqn{\fv : \texttt{S.t} \to \texttt{SparcAsm.exp} \to \texttt{S.t}} \\
\fv_s(c) & = & s \\
\fv_s(\lab_x) & = & s \\
\fv_s(\OP(x_1, \dots, x_n)) & = & \{x_1, \dots, x_n\} \cup s \\
\fv_s(\IF~x = y~\THEN~E_1~\ELSE~E_2) & = & \{x, y\} \cup \fv_s(E_1) \cup \fv_s(E_2) \\
\fv_s(\IF~x \le y~\THEN~E_1~\ELSE~E_2) & = & \{x, y\} \cup \fv_s(E_1) \cup \fv_s(E_2) \\
\fv_s(x) & = & \{x\} \cup s \\
\fv_s(\apcls(x, y_1, \dots, y_n)) & = & \{x, y_1, \dots, y_n\} \cup s \\
\fv_s(\apdir(\lab_x, y_1, \dots, y_n)) & = & \{y_1, \dots, y_n\} \cup s \\
\fv_s(x.(y)) & = & \{x, y\} \cup s \\
\fv_s(x.(y) \leftarrow z) & = & \{x, y, z\} \cup s \\
\fv_s(\SAVE(x, y)) & = & \{x\} \cup s \\
\fv_s(\REST(y)) & = & s \\
\end{array}
\]
\caption{命令の列$E$および式$e$において生きている変数の集合$\fv_s(E)$および$\fv_s(e)$。$s$は$E$や$e$の後で使われる変数の集合。以後の$\fv(E)$は$\fv_\emptyset(E)$の略記。}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{lll}
\lefteqn{\R : \texttt{SparcAsm.prog} \to \texttt{SparcAsm.prog}} \\
\R((\{D_1, \dots, D_n\}, E)) & = & (\{\R(D_1), \dots, \R(D_n)\}, \R_\emptyset(E, x, ())) \qquad \hfill \mbox{$x$はダミーのfreshな変数} \\
\\
\lefteqn{\R : \texttt{SparcAsm.fundef} \to \texttt{SparcAsm.fundef}} \\
\R(\lab_x (y_1, \dots, y_n) = E) & = & \lab_x (\reg{1}, \dots, \reg{n}) = \R_{x \mapsto \reg{0}, y_1 \mapsto \reg{1}, \dots, y_n \mapsto \reg{n}}(E, \reg{0}, \reg{0}) \\
\\
\lefteqn{\R : \texttt{Id.t M.t} \to \texttt{SparcAsm.t} \times \texttt{Id.t} \times \texttt{SparcAsm.t} \to \texttt{SparcAsm.t} \times \texttt{Id.t M.t}} \\
\R_\e((x \leftarrow e; E), z_\dest, E_\cont) & = & E_\cont' = (z_\dest \leftarrow E; E_\cont), \\
& & \R_\e(e, x, E_\cont') = (E', \e'), \\
& & r \not\in \{\e'(y) \mid y \in \fv(E_\cont')\}, \\
& & \R_{\e', x \mapsto r}(E, z_\dest, E_\cont) = (E'', \e'') \mbox{として} \\
& & ((r \leftarrow E'; E''), \e'') \hfill \mbox{$x$がレジスタでない場合} \\
\R_\e((r \leftarrow e; E), z_\dest, E_\cont) & = & E_\cont' = (z_\dest \leftarrow E; E_\cont), \\
& & \R_\e(e, r, E_\cont') = (E', \e'), \\
& & \R_{\e'}(E, z_\dest, E_\cont) = (E'', \e'') \mbox{として} \\
& & ((r \leftarrow E'; E''), \e'') \\
\R_\e(e, x, E_\cont) & = & \R_\e(e, x, E_\cont) \hfill \mbox{（次図参照）} \\
\end{array}
\]
\caption{単純なレジスタ割り当て$\R(P)$, $\R(D)$および$\R_\e(E, z_\dest, E_\cont)$。$\e$は変数からレジスタへの写像、$z_\dest$は$E$の結果をセットする変数、$E_\cont$は$E$の後に実行される命令の列。$\R_\e(E, x, E_\cont)$の返り値はレジスタ割り当てされた命令の列$E'$と、$E$の後のレジスタ割り当てを表す写像$\e'$の組。[ファイル\texttt{regAlloc.notarget-nospill.ml}参照]}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{lll}
\lefteqn{\R : \texttt{Id.t M.t} \to \texttt{SparcAsm.exp} \times \texttt{Id.t} \times \texttt{SparcAsm.t} \to \texttt{SparcAsm.t} \times \texttt{Id.t M.t}} \\
\R_\e(c, z_\dest, E_\cont) & = & (c, \e) \\
\R_\e(\lab_x, z_\dest, E_\cont) & = & (\lab_x, \e) \\
\R_\e(\OP(x_1, \dots, x_n), z_\dest, E_\cont) & = & (\OP(\e(x_1), \dots, \e(x_n)), \e) \\
\R_\e(\IF~x = y~\THEN~E_1~\ELSE~E_2, z_\dest, E_\cont) & = & \R_\e(E_1, z_\dest, E_\cont) = (E_1', \e_1), \\
& & \R_\e(E_2, z_\dest, E_\cont) = (E_2', \e_2), \\
& & \e' = \{z \mapsto r \mid \e_1(z) = \e_2(z) = r\}, \\
& & \{z_1, \dots, z_n\} = \\
& & \hfill (\fv(E_\cont) \setminus \{z_\dest\} \setminus \dom(\e')) \cap \dom(\e) \mbox{として} \\
& & ((\SAVE(\e(z_1), z_1); \dots; \SAVE(\e(z_n), z_n); \\
& & \phantom{((} \IF~\e(x) \le \e(y)~\THEN~E_1'~\ELSE~E_2'), \e') \\
\R_\e(\IF~x \le y~\THEN~E_1~\ELSE~E_2, z_\dest, E_\cont) & = & \mbox{同様} \\
\R_\e(x, z_\dest, E_\cont) & = & (\e(x), \e) \\
\R_\e(\apcls(x, y_1, \dots, y_n), z_\dest, E_\cont) & = & \{z_1, \dots, z_n\} = (\fv(E_\cont) \setminus \{z_\dest\}) \cap \dom(\e) \mbox{として} \\
& & ((\SAVE(\e(z_1), z_1); \dots; \SAVE(\e(z_n), z_n); \\
& & \phantom{((} \apcls(\e(x), \e(y_1), \dots, \e(y_n))), \emptyset)\\
\R_\e(\apdir(\lab_x, y_1, \dots, y_n), z_\dest, E_\cont) & = & \mbox{同様} \\
\R_\e(x.(y), z_\dest, E_\cont) & = & (\e(x).(\e(y)), \e) \\
\R_\e(x.(y) \leftarrow z, z_\dest, E_\cont) & = & (\e(x).(\e(y)) \leftarrow \e(z), \e) \\
\R_\e(\SAVE(x, y), z_\dest, E_\cont) & = & (\SAVE(\e(x), y), \e) \\
\R_\e(\REST(y), z_\dest, E_\cont) & = & (\REST(y), \e) \\
\end{array}
\]
\caption{単純なレジスタ割り当て$\R_\e(e, z_\dest, E_\cont)$。$\R_\e(e)$の右辺で変数$x$のレジスタ$\e(x)$が定義されていない場合は、$\R_\e(e) = \R_\e(x \leftarrow \REST(x); e)$とする。ただしレジスタ$r$については$\e(r) = r$とする。[ファイル\texttt{regAlloc.notarget-nospill.ml}参照]}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{lll}
\lefteqn{\T : \texttt{Id.t} \to \texttt{SparcAsm.t} \times \texttt{Id.t} \to \BOOL \times \texttt{S.t}}\\
\T_x((y \leftarrow e; E), z_\dest) & = & \T_x(e, y) = (c_1, s_1) \mbox{として、もし} c_1 \mbox{ならば} (\mathit{true}, s_1) \\
& & \mbox{そうでなければ} \T_x(E, z_\dest) = (c_2, s_2) \mbox{として} (c_2, s_1 \cup s_2) \\
\T_x(e, z_\dest) & = & \T_x(e, z_\dest) \\
\\
\lefteqn{\T : \texttt{Id.t} \to \texttt{SparcAsm.exp} \times \texttt{Id.t} \to \BOOL \times \texttt{S.t}}\\
\T_x(x, z_\dest) & = & (\mathit{false}, \{z_\dest\}) \\
\T_x(\IF~y = z~\THEN~E_1~\ELSE~E_2, z_\dest) & = & \T_x(E_1, z_\dest) = (c_1, s_1), \\
& & \T_x(E_2, z_\dest) = (c_2, s_2) \mbox{として} \\
& & (c_1 \land c_2, s_1 \cup s_2) \\
\T_x(\IF~y \le z~\THEN~E_1~\ELSE~E_2, z_\dest) & = & \mbox{同上} \\
\T_x(\apcls(y_0, y_1, \dots, y_n), z_\dest) & = & (\mathit{true}, \{\reg{i} \mid x = y_i\}) \\
\T_x(\apdir(\lab_y, y_1, \dots, y_n), z_\dest) & = & \mbox{同上} \\
\T_x(e, z_\dest) & = & (\mathit{false}, \emptyset) \hfill \mbox{それ以外の場合}  \\
\end{array}
\]
\caption{変数$x$に割り当てるレジスタ$r$を選ぶときに使うtargeting $\T_x(E, z_\dest)$および$\T_x(e, z_\dest)$。$E$や$e$で関数呼び出しがあったかどうかを表す論理値$c$と、$x$を割り当てると良いレジスタの集合$s$の組を返す。前々図の「$x$がレジスタでない場合」において、$\T_x(E_\cont', z_\dest) = (c, s)$として、できれば$r \in s$とする。[ファイル\texttt{regAlloc.target-nospill.ml}参照]}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{lll}
\lefteqn{\R : \texttt{Id.t M.t} \to \texttt{SparcAsm.t} \times \texttt{Id.t} \times \texttt{SparcAsm.t} \to \texttt{SparcAsm.t} \times \texttt{Id.t M.t}} \\
\R_\e((x \leftarrow e; E), z_\dest, E_\cont) & = & E_\cont' = (z_\dest \leftarrow E; E_\cont), \\
& & \R_\e(e, x, E_\cont') = (E', \e'), \\
& & y \in \fv(E_\cont'), \\
& & \R_{\e' \setminus \{y \mapsto \e'(y)\}, x \mapsto \e'(y)}(E, z_\dest, E_\cont) = (E'', \e'') \mbox{として} \\
& & \left\{
  \begin{array}{ll}
    ((\SAVE(\e(y), y); \e'(y) \leftarrow E'; E''), \e'') & \mbox{$y \in \dom(\e)$のとき} \\
    ((\e'(y) \leftarrow E'; E''), \e'') & \mbox{$y \not\in \dom(\e)$のとき} \\
  \end{array}
  \right. \\
  & & \hfill
  \begin{array}{l}
    \mbox{$x$がレジスタでなく、} \\
    \mbox{$r \not\in \{\e'(y) \mid y \in \fv(E_\cont')\}$なる$r$がない場合} \\
  \end{array} \\
\end{array}
\]
\caption{spillingをするレジスタ割り当て$\R_\e(E, z_\dest, E_\cont)$ [ファイル\texttt{regAlloc.target-latespill.ml}参照]}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{lll}
\lefteqn{\s : \texttt{SparcAsm.prog} \to \texttt{string}} \\
\s((\{D_1, \dots, D_n\}, E)) & = & \verb|.section ".text"| \\
& & \s(D_1) \\
& & \dots \\
& & \s(D_n) \\
& & \verb|.global min_caml_start| \\
& & \verb|min_caml_start:| \\
& & \verb|save %sp, -112, %sp| \\
& & \s(E, \verb|%g0|) \\
& & \verb|ret| \\
& & \verb|restore| \\
\\
\lefteqn{\s : \texttt{SparcAsm.fundef} \to \texttt{string}} \\
\s(\lab_x (y_1, \dots, y_n) = E) & = & x\verb|:| \\
& & \s(E, \reg{0}) \\
& & \verb|retl| \\
& & \verb|nop| \\
\\
\lefteqn{\s : \texttt{SparcAsm.t} \times \texttt{Id.t} \to \texttt{string}} \\
\s((x \leftarrow e; E), z_\dest) & = & \s(e, x) \\
& & \s(E, z_\dest) \\
\s(e, z_\dest) & = & \s(e, z_\dest) \\
\end{array}
\]
\caption{単純なアセンブリ生成$\s(P)$, $\s(D)$および$\s(E, z_\dest)$}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{lll}
\lefteqn{\s : \texttt{SparcAsm.exp} \times \texttt{Id.t} \to \texttt{string}} \\
\s(c, z_\dest) & = & \verb|set|~c, z_\dest \\
\s(\lab_x, z_\dest) & = & \verb|set|~\lab_x, z_\dest \\
\s(\OP(x_1, \dots, x_n), z_\dest) & = & \OP~x_1, \dots, x_n, z_\dest \\
\s(\IF~x = y~\THEN~E_1~\ELSE~E_2, z_\dest) & = & \verb|cmp|~x, y \\
& & \verb|bne|~b_1 \\
& & \verb|nop| \\
& & \s(E_1, z_\dest) \\
& & \verb|b|~b_2 \\
& & \verb|nop| \\
& & b_1\verb|:| \\
& & \s(E_2, z_\dest) \\
& & b_2\verb|:| \\
\s(\IF~x \le y~\THEN~E_1~\ELSE~E_2, z_\dest) & = & \mbox{同様} \\
\s(x, z_\dest) & = & \verb|mov|~x, z_\dest \\
\s(\apcls(x, y_1, \dots, y_n), z_\dest) & = & \mathit{shuffle}((x, y_1, \dots, y_n), (\reg{0}, \reg{1}, \dots, \reg{n})) \\
& & \verb|st|~\ra, [\st + 4\#\e] \\
& & \verb|ld|~[\reg{0}], \reg{n+1} \\
& & \verb|call|~\reg{n+1} \\
& & \verb|add|~\st, 4(\#\e+1), \st~\verb|!|~\mbox{\textit{delay slot}} \\
& & \verb|sub|~\st, 4(\#\e+1), \st \\
& & \verb|ld|~[\st + 4\#\e], \ra \\
& & \verb|mov|~\reg{0}, z_\dest \\
\s(\apdir(\lab_x, y_1, \dots, y_n), z_\dest) & = & \mathit{shuffle}((y_1, \dots, y_n), (\reg{1}, \dots, \reg{n})) \\
& & \verb|st|~\ra, [\st + 4\#\e] \\
& & \verb|call|~x \\
& & \verb|add|~\st, 4(\#\e+1), \st~\verb|!|~\mbox{\textit{delay slot}} \\
& & \verb|sub|~\st, 4(\#\e+1), \st \\
& & \verb|ld|~[\st + 4\#\e], \ra \\
& & \verb|mov|~\reg{0}, z_\dest \\
\s(x.(y), z_\dest) & = & \verb|ld|~[x + y], z_\dest \\
\s(x.(y) \leftarrow z, z_\dest) & = & \verb|st|~z, [x + y] \\
\s(\SAVE(x, y), z_\dest) & = & \mbox{もし$y \not\in \dom(\e)$なら$\e$に$y \mapsto 4\#\e$を加えて} \\
& & \verb|st|~x, [\st + \e(y)] \\
\s(\REST(y), z_\dest) & = & \verb|ld|~[\st + \e(y)], z_\dest \\
\end{array}
\]
\caption{単純なアセンブリ生成$\s(e, z_\dest)$。$\e$はスタック位置を記憶するグローバル変数。$\#\e$は$\e$の要素の個数。$\mathit{shuffle}((x_1, \dots, x_n), (r_1, \dots, r_n))$は$x_1$, \dots, $x_n$を$r_1$, \dots, $r_n$に適切な順序で移動する命令。}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{lll}
\lefteqn{\s : \texttt{S.t} \to \texttt{SparcAsm.t} \times \texttt{Id.t} \to \texttt{S.t} \times \texttt{string}} \\
\s_s((x \leftarrow e; E), z_\dest) & = & \s_s(e, x) = (s', S), \\
& & \s_{s'}(E, z_\dest) = (s'', S') \mbox{として} \\
& & (s'', S S') \\
\s_s(e, z_\dest) & = & \s_s(e, z_\dest) \\
\\
\lefteqn{\s : \texttt{S.t} \to \texttt{SparcAsm.exp} \times \texttt{Id.t} \to \texttt{S.t} \times \texttt{string}} \\
\s_s(\IF~x = y~\THEN~E_1~\ELSE~E_2, z_\dest) & = & \s_s(E_1, z_\dest) = (s_1, S_1), \\
& & \s_s(E_2, z_\dest) = (s_2, S_2) \mbox{として} \\
& & (s_1 \cap s_2, \\
& & \phantom{(}\verb|cmp|~x, y \\
& & \phantom{(}\verb|bne|~b_1 \\
& & \phantom{(}\verb|nop| \\
& & \phantom{(}S_1 \\
& & \phantom{(}\verb|b|~b_2 \\
& & \phantom{(}\verb|nop| \\
& & \phantom{(}b_1\verb|:| \\
& & \phantom{(}S_2 \\
& & \phantom{(}b_2\verb|:|) \\
\s_s(\IF~x \le y~\THEN~E_1~\ELSE~E_2, z_\dest) & = & \mbox{同様} \\
\s_s(\SAVE(x, y), z_\dest) & = & (s, \verb|nop|) \hfill \mbox{$y \in s$の場合} \\
\s_s(\SAVE(x, y), z_\dest) & = & \mbox{もし$y \not\in \dom(\e)$なら$\e$に$y \mapsto 4\#\e$を加えて} \\
& & (s \cup \{y\}, \verb|st|~x, [\st + \e(y)]) \hfill \mbox{$y \not\in s$の場合} \\
\s_s(e, z_\dest) & = & (s, \mbox{以前と同様}) \hfill \mbox{上述以外の場合} \\
\end{array}
\]
\caption{無駄な$\SAVE$を省略するアセンブリ生成$\s_s(E, z_\dest)$および$\s_s(e, z_\dest)$。$s$はすでに$\SAVE$された変数の名前の集合。以前の$\s(E, z_\dest)$は$\s_\emptyset(E, z_\dest) = (s, S)$として$S$の略記とする。}
}\fbox{\box0}
\end{figure*}

\begin{figure*}
\setbox0\vbox{
\[
\begin{array}{lll}
\lefteqn{\s : \texttt{SparcAsm.fundef} \to \texttt{string}} \\
\s(\lab_x (y_1, \dots, y_n) = E) & = & \s_\emptyset(E, \tail) = (s, S) \mbox{として} \\
& & x\verb|:| \\
& & S \\
\\
\lefteqn{\s : \texttt{S.t} \to \texttt{SparcAsm.exp} \times \texttt{Id.t} \to \texttt{S.t} \times \texttt{string}} \\
\s_s(\IF~x = y~\THEN~E_1~\ELSE~E_2, \tail) & = & \s_s(E_1, \tail) = (s_1, S_1), \\
& & \s_s(E_2, \tail) = (s_2, S_2) \mbox{として} \\
& & (\emptyset, \\
& & \phantom{(}\verb|cmp|~x, y \\
& & \phantom{(}\verb|bne|~b \\
& & \phantom{(}\verb|nop| \\
& & \phantom{(}S_1 \\
& & \phantom{(}b\verb|:| \\
& & \phantom{(}S_2) \\
\s_s(\IF~x \le y~\THEN~E_1~\ELSE~E_2, \tail) & = & \mbox{同様} \\
\s_s(\apcls(x, y_1, \dots, y_n), \tail) & = & (\emptyset, \\
& & \phantom{(}\mathit{shuffle}((x, y_1, \dots, y_n), (\reg{0}, \reg{1}, \dots, \reg{n})) \\
& & \phantom{(}\verb|ld|~[\reg{0}], \reg{n+1} \\
& & \phantom{(}\verb|jmp|~\reg{n+1} \\
& & \phantom{(}\verb|nop|) \\
\s_s(\apdir(\lab_x, y_1, \dots, y_n), \tail) & = & (\emptyset, \\
& & \phantom{(}\mathit{shuffle}((y_1, \dots, y_n), (\reg{1}, \dots, \reg{n})) \\
& & \phantom{(}\verb|b|~x \\
& & \phantom{(}\verb|nop|) \\
\s_s(e, \tail) & = & \s_s(e, \reg{0}) = (s', S) \mbox{として} \\
& & (\emptyset, \\
& & \phantom{(}S \\
& & \phantom{(}\verb|retl| \\
& & \phantom{(}\verb|nop|) \hfill \mbox{上述以外の場合} \\
\end{array}
\]
\caption{末尾呼び出し最適化をするアセンブリ生成$\s_s(D)$および$\s_s(e, z_\dest)$。$z_\dest = \tail$の場合が末尾。}
}\fbox{\box0}
\end{figure*}

\end{document}
