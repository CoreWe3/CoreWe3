<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=ascii">
<link rel=Edit-Time-Data href="./tutorial-mincaml.files/editdata.mso">
<link rel="stylesheet" href="sh.css" type="text/css">
<title>A Crash Course for the MinCaml Compiler</title>
</head>
<body bgcolor="#FFFFFF" link=blue vlink=purple class="Normal">
<div>
  <h3>Parsing (<tt>parser.mly</tt>)</h3>
  <p>Now that lexical analysis is done, instead of strings like </p>
  <p align=center style='text-align:center;'><tt>'1' '2' '3' '-' '4' '5' '6' '+' '7' '8' '9'</tt></p>
  <p>we have sequences of tokens like</p>
  <p align=center style='text-align:center;'><tt>&quot;123&quot; &quot;-&quot; &quot;456&quot; &quot;+&quot; &quot;789&quot;</tt>.</p>
  <p>However, we still cannot do any high-level processing on such a flat sequence as above. For example, we have to recognize &quot;<tt>123-456+789</tt>&quot; to be &quot;<tt>(123-456)+789</tt>&quot;, not &quot;<tt>123-(456+789)</tt>&quot;. In terms of the data type <tt>Syntax.t</tt> defined in <tt>syntax.ml</tt>, we need a <em>parse tree</em> like: </p>
  <p align=center style='text-align:center;'><tt>Add(Sub(Int 123, Int 456), Int 789)</tt></p>
  <p>This process of translating a sequence of tokens into a parse tree is called <em>parsing</em>. The MinCaml compiler uses a tool called <a target="_blank"
href="http://caml.inria.fr/pub/docs/manual-ocaml/manual026.html"><tt>ocamlyacc</tt></a> to implement parsing in file <tt>parser.mly</tt>.</p>
  <p>The contents of <tt>parser.mly</tt> are more or less similar to those of <tt>lexer.mll</tt>. It lists pattern matching from sequences of tokens to parse trees, for example <a target="srcview"
href="min-caml.html#parser_add">like</a>: </p>
  <p><tt>| exp PLUS exp<br>
&nbsp;&nbsp;&nbsp; { Add($1, $3) }</tt></p>
  <p><tt>$1</tt> and <tt>$3</tt> mean the first and third syntax elements (which are both <tt>exp</tt> in this case).</p>
  <p>This definition of syntax is almost the same as the previously described expressions <tt>e</tt>, but one point needs caution. In ML, function applcation is denoted by just a sequence of expressions. Therefore, if you write <tt>x - y</tt>, it is ambiguous whether you are subtracting integer <tt>y</tt> from integer <tt>x</tt> or applying function <tt>x</tt> to argument <tt>-y</tt>! Thus, we distinguish simple expressions <a target="srcview"
href="min-caml.html#parser_simple"><tt>simple_exp</tt></a>, which can be function arguments without extra parentheses, from general expressions <a target="srcview"
href="min-caml.html#parser_exp"><tt>exp</tt></a>. For example, since <tt>-y</tt> is not a <tt>simple_exp</tt>, the previous expression is known to be integer subtraction, not function application.</p>
  <p><tt>parser.mly</tt> also defines <a target="srcview"
href="min-caml.html#parser_prior">the priority of various syntax and binary operators</a> as well as <a target="srcview"
href="min-caml.html#parser_token">the data type of tokens</a> mentioned in <tt>lexer.mll</tt>.</p>
  <p>By the way, whenever the type of a variable is required (as in <tt>let</tt>), it is given by a fresh, undefined type variable <tt>Var(ref None)</tt> for the moment. This point will be explained next in type inference.</p>
  <p><a
href="tutorial-mincaml-8.eng.htm">Next</a></p>
</div>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-1484933-2";
urchinTracker();
</script>
</body>
</html>
