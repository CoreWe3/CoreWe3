<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=ascii">
<link rel=Edit-Time-Data href="./tutorial-mincaml.files/editdata.mso">
<link rel="stylesheet" href="sh.css" type="text/css">
<title>A Crash Course for the MinCaml Compiler</title>
</head>
<body bgcolor="#FFFFFF" link=blue vlink=purple class="Normal">
<div>
  <h3>The Syntax and Types of MinCaml</h3>
  <p>MinCaml is a subset of ML. Except for some details such as priority and parentheses, it has the following syntax.</p>
  <table width="100%%" >
    <tr>
      <td width="50%">e ::=</td>
      <td>expressions</td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;c</td>
      <td>constants</td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;op(e<sub>1</sub>, ..., e<sub>n</sub>)</td>
      <td>primitive operations</td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;<tt>if </tt>e<sub>1</sub><tt> then </tt>e<sub>2</sub><tt> else </tt>e<sub>3</sub></td>
      <td>conditional branches</td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;<tt>let </tt>x<tt> = </tt>e<sub>1</sub><tt> in </tt>e<sub>2</sub></td>
      <td>variable definitions </td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;x</td>
      <td>variables </td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;<tt>let rec </tt>x y<sub>1</sub> ... y<sub>n</sub><tt> = </tt>e<sub>1</sub><tt> </tt><tt>in </tt>e<sub>2</sub></td>
      <td>function definitions (mutually recursive)</td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;e e<sub>1</sub> ... e<sub>n</sub></td>
      <td>function applications</td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;<tt>(</tt>e<sub>1</sub><tt>, </tt>...<tt>, </tt>e<sub>n</sub><tt>)</tt></td>
      <td>tuple creations </td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;<tt>let (</tt>x<sub>1</sub><tt>, </tt>...<tt>, </tt>x<sub>n</sub><tt>) = </tt>e<sub>1</sub><tt> in </tt>e<sub>2</sub></td>
      <td>read from tuples </td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;<tt>Array.create </tt>e<sub>1</sub><tt> </tt>e<sub>2</sub></td>
      <td>array creations </td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;e<sub>1</sub><tt>.(</tt>e<sub>2</sub><tt>)</tt></td>
      <td>read from arrays </td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;e<sub>1</sub><tt>.(</tt>e<sub>2</sub><tt>) &lt;- </tt>e<sub>3</sub></td>
      <td>write to arrays </td>
    </tr>
  </table>
  <p>It is expressed as ML data type <a target="srcview"
href="min-caml.html#syntax_t"><tt>Syntax.t</tt></a> in module <tt>syntax.ml</tt>. Expressions (such as <tt>let</tt> and <tt>let rec</tt>) defining new variables also include their types, which are not shown above. Those types are expressed by <a target="srcview"
href="min-caml.html#type_t"><tt>Type.t</tt></a>, defined in <tt>type.ml</tt>.</p>
  <table width="100%%">
    <tr>
      <td width="50%">T ::=</td>
      <td>types</td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;&pi;</td>
      <td>primitive types </td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;T<sub>1</sub><tt> -> </tt>...<tt> -> </tt>T<sub>n</sub><tt> -> </tt>T</td>
      <td>function types </td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;T<sub>1</sub><tt> * </tt>...<tt> * </tt>T<sub>n</sub></td>
      <td> tuple types </td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;T<tt> array</tt></td>
      <td>array types </td>
    </tr>
    <tr>
      <td width="50%">&nbsp;&nbsp;&alpha;</td>
      <td>type variables </td>
    </tr>
  </table>
  <p>The last &quot;type variables&quot; will be used in type inference.</p>
  <p>By the way, the MinCaml compiler does not automatically support so-called partial application of curried functions. That is, every function application needs all arguments at once. If you want partial application, you need to define the intermediate function by hand, like <tt>let rec f_123 x = f 123 x in f_123</tt>. (If you know the Scheme language, it is similar in this respect.)</p>
  <p>Also, there are no &quot;reference cells,&quot; which are necessary for imperative programming, but they can be substituted by arrays with only one element. Specifically, <tt>ref e</tt> can be substituted with <tt>Array.create 1 e</tt>, <tt>!e</tt> with <tt>e.(0)</tt>, and <tt>e<sub>1</sub> := e<sub>2</sub></tt> with <tt>e<sub>1</sub>.(0) &lt;- e<sub>2</sub></tt>.</p>
  <p><a
href="tutorial-mincaml-5.eng.htm">Next</a></p>
</div>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-1484933-2";
urchinTracker();
</script>
</body>
</html>
